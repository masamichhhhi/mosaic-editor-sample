# モザイク描画方式の修正計画

## 修正日時
2026年1月12日

---

## 1. 現状の問題点

### 現在の実装（MosaicCanvas.tsx 191-211行目）
```typescript
const drawMosaic = () => {
  // ...
  activeRegions.forEach((region) => {
    const pixelSize = 8;
    for (let py = 0; py < h; py += pixelSize) {
      for (let px = 0; px < w; px += pixelSize) {
        const brightness = Math.floor(Math.random() * 60 + 60);
        ctx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness}, 0.85)`;
        ctx.fillRect(x + px, y + py, pixelSize - 1, pixelSize - 1);
      }
    }
  });
};
```

### 問題点
- ランダムなグレーのピクセルパターンを描画しているだけ
- 実際の動画内容とは無関係な擬似モザイク
- 動画の元画像を活用していないため、不自然な見た目

---

## 2. 修正方針

### 目標
動画フレームから該当領域の画像を抽出し、その画像にblurフィルターを適用することで、リアルなモザイク効果を実現する。

### 技術的アプローチ
1. **動画フレームの取得**: `<video>`要素から`drawImage()`でCanvasに現在のフレームを描画
2. **領域の抽出**: `getImageData()`で指定領域のピクセルデータを取得
3. **Blur適用**: Canvas APIの`filter`プロパティを使用
4. **合成描画**: ぼかした領域をオーバーレイとして描画

---

## 3. 実装詳細

### 3.1 新しいモザイク描画ロジック

```typescript
const drawMosaic = () => {
  ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
  
  const activeRegions = getActiveRegions(video.currentTime);
  if (activeRegions.length === 0) return;
  
  // 動画の表示サイズと実際のサイズの比率を計算
  const scaleX = video.videoWidth / canvasSize.width;
  const scaleY = video.videoHeight / canvasSize.height;
  
  activeRegions.forEach((region) => {
    // 1. オフスクリーンCanvasを作成
    const offscreen = document.createElement('canvas');
    offscreen.width = region.width;
    offscreen.height = region.height;
    const offCtx = offscreen.getContext('2d');
    if (!offCtx) return;
    
    // 2. 動画から該当領域を抽出してオフスクリーンCanvasに描画
    offCtx.drawImage(
      video,
      region.x * scaleX,    // ソースX（動画の実座標）
      region.y * scaleY,    // ソースY
      region.width * scaleX, // ソース幅
      region.height * scaleY, // ソース高さ
      0,                     // 出力X
      0,                     // 出力Y
      region.width,          // 出力幅
      region.height          // 出力高さ
    );
    
    // 3. Blurフィルターを適用して描画
    ctx.filter = 'blur(10px)';
    ctx.drawImage(offscreen, region.x, region.y);
    ctx.filter = 'none';
  });
};
```

### 3.2 修正が必要なファイル

| ファイル | 修正内容 |
|---------|---------|
| `src/components/MosaicCanvas.tsx` | `drawMosaic`関数のモザイク描画ロジックを変更 |

### 3.3 変更箇所の詳細

#### Before（擬似モザイク）
```typescript
activeRegions.forEach((region) => {
  const x = region.x;
  const y = region.y;
  const w = region.width;
  const h = region.height;
  
  // モザイクパターンの描画
  const pixelSize = 8;
  for (let py = 0; py < h; py += pixelSize) {
    for (let px = 0; px < w; px += pixelSize) {
      const brightness = Math.floor(Math.random() * 60 + 60);
      ctx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness}, 0.85)`;
      ctx.fillRect(x + px, y + py, pixelSize - 1, pixelSize - 1);
    }
  }
});
```

#### After（実画像ベースのBlurモザイク）
```typescript
// 動画の表示サイズと実際のサイズの比率を計算
const scaleX = video.videoWidth / canvasSize.width;
const scaleY = video.videoHeight / canvasSize.height;

activeRegions.forEach((region) => {
  // オフスクリーンCanvasに動画の該当領域を描画
  const offscreen = document.createElement('canvas');
  offscreen.width = region.width;
  offscreen.height = region.height;
  const offCtx = offscreen.getContext('2d');
  if (!offCtx) return;
  
  // 動画から該当領域を抽出
  offCtx.drawImage(
    video,
    region.x * scaleX,
    region.y * scaleY,
    region.width * scaleX,
    region.height * scaleY,
    0, 0,
    region.width,
    region.height
  );
  
  // Blurフィルターを適用して描画
  ctx.filter = 'blur(10px)';
  ctx.drawImage(offscreen, region.x, region.y);
  ctx.filter = 'none';
});
```

---

## 4. 技術的考慮事項

### 4.1 パフォーマンス最適化

| 課題 | 対策 |
|------|------|
| 毎フレームでのオフスクリーンCanvas生成 | オフスクリーンCanvasをキャッシュして再利用 |
| 大きな領域でのBlur処理の負荷 | `requestAnimationFrame`での適切なフレームスキップ |
| 複数領域の同時処理 | 領域ごとにオフスクリーンCanvasを1つにまとめる |

### 4.2 座標変換

動画の表示サイズ（CSS）と実際の解像度（videoWidth/videoHeight）が異なる場合があるため、座標変換が必要：

```
表示座標 → 動画実座標
x_video = x_display * (videoWidth / displayWidth)
y_video = y_display * (videoHeight / displayHeight)
```

### 4.3 Blur強度の調整

```typescript
// Blur強度をカスタマイズ可能にする場合
const BLUR_INTENSITY = 10; // px
ctx.filter = `blur(${BLUR_INTENSITY}px)`;
```

---

## 5. 実装手順

### Step 1: drawMosaic関数の修正
- 現在のランダムピクセル描画ロジックを削除
- 動画フレーム抽出 + Blur適用ロジックを実装

### Step 2: 座標変換の追加
- 動画の実サイズと表示サイズの比率計算を追加
- `drawImage`の座標を適切に変換

### Step 3: パフォーマンス最適化（オプション）
- オフスクリーンCanvasの再利用
- 領域サイズに応じたBlur強度の動的調整

---

## 6. 期待される結果

### Before
- ランダムなグレーのピクセルパターン
- 動画内容とは無関係な見た目
- 「モザイク」というより「ノイズ」に近い表現

### After
- 実際の動画画像をぼかしたリアルなモザイク
- 元の画像の色味・形状が残るため自然な見た目
- プライバシー保護目的のモザイクとして適切

---

## 7. テスト項目

- [ ] 動画再生中にモザイクが正しく表示されること
- [ ] 動画停止中にもモザイクが表示されること
- [ ] モザイク領域の移動・リサイズ後も正しく表示されること
- [ ] 複数のモザイク領域が同時に正しく描画されること
- [ ] パフォーマンスに大きな影響がないこと

---

*作成日: 2026年1月12日*
